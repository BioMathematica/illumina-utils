#!/bin/env python
# -*- coding: utf-8 -*-

import re
import os
import sys
import cPickle
import hashlib
import tempfile
import operator
import subprocess
import ConfigParser

sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), '..'))

import fastqlib as u
import fastalib as f
from runconfiguration import RunConfiguration
from runconfiguration import ConfigError

conv_dict = {'A': 'T',
             'T': 'A',
             'C': 'G',
             'G': 'C',
             'N': 'N'}

NumberOfConflicts = lambda s: sum([True for n in s if n in conv_dict])
ConflictPositions = lambda s: [i for i in range(0, len(s)) if s[i] in conv_dict]

def merge_two_sequences(seq1, seq2):
    temp_seq_1 = tempfile.NamedTemporaryFile(delete=False)
    temp_seq_1_path = temp_seq_1.name
    temp_seq_2 = tempfile.NamedTemporaryFile(delete=False)
    temp_seq_2_path = temp_seq_2.name
    temp_merge_path = tempfile.NamedTemporaryFile(delete=False).name
    
    temp_seq_1.write('>1\n' + seq1 + '\n')
    temp_seq_2.write('>2\n' + seq2 + '\n')
    
    temp_seq_1.close()
    temp_seq_2.close()

    merger_process = ['merger', temp_seq_1_path, temp_seq_2_path, '-outseq', temp_merge_path, '-gapopen', '25', '-outfile', '/dev/null']
    if subprocess.call(merger_process, stderr=open('/dev/null', 'w')) == 0:
        merged = f.SequenceSource(temp_merge_path)
        merged.next()
        merged.close()

        os.remove(temp_seq_1_path)
        os.remove(temp_seq_2_path)
        os.remove(temp_merge_path)

        return merged.seq
    else:
        print 'Something went wrong while merging these: \n\n%s\n--\n%s\n\n' % (seq1, seq2)
        sys.exit(-2)


def reverse_complement(seq):
    return ''.join(reversed([conv_dict[n] for n in seq]))


def reverse(seq):
    return ''.join(reversed(seq))


def complement(seq):
    return ''.join([conv_dict[n] for n in seq])


def main(config, output_file_prefix, compute_qual_dicts = False, pair_1_prefix = None, pair_2_prefix = None):

    actual_number_of_pairs = 0
    prefix_failed_in_pair_1_total = 0
    prefix_failed_in_pair_2_total = 0
    prefix_failed_in_both_pairs_total = 0
    passed_prefix_total = 0
    failed_prefix_total = 0
    zero_mismatches_total = 0

    if pair_1_prefix:
        pair_1_prefix_compiled = re.compile(pair_1_prefix)
    else:
        pair_1_prefix_compiled = None
    
    if pair_2_prefix:
        pair_2_prefix_compiled = re.compile(pair_2_prefix)
    else:
        pair_2_prefix_compiled = None


    quality_dicts = {-1: {'1': {}, '2': {}}, 0: {'1': {}, '2': {}}, 1: {'1': {}, '2': {}}, 2: {'1': {}, '2': {}}, 3: {'1': {}, '2': {}}, 4: {'1': {}, '2': {}}, 5: {'1': {}, '2': {}}}
            
    output = f.FastaOutput(os.path.join(config.output_directory, output_file_prefix + '_MERGED' ))
    failed = f.FastaOutput(os.path.join(config.output_directory, output_file_prefix + '_FAILED' ))
    
    ########################################################################################################################
    # merging..
    ########################################################################################################################

    sys.stderr.write('POK: "Percent of all pairs that did present the prefix defined by the user\n"')
    sys.stderr.write('ZM : "Percent of all pairs that merged with 0 mismatch\n"')

    for index in range(0, len(config.pair_1)):
        try:
            F = lambda x: os.path.basename(x).split('.')[0]
            input_1 = u.FastQSource(config.pair_1[index], compressed = config.pair_1[index].endswith('.gz'))
            input_2 = u.FastQSource(config.pair_2[index], compressed = config.pair_2[index].endswith('.gz'))

        except u.FastQLibError, e:
            print "FastQLib is not happy.\n\n\t", e, "\n"
            sys.exit()

        while input_1.next() and input_2.next():
            actual_number_of_pairs += 1
            if input_1.p_available:
                if pair_1_prefix_compiled or pair_2_prefix_compiled:
                    input_1.print_percentage('[Merging %d of %d] POK: %.1f%% :: ZM: %.1f%%' \
                                % (index + 1,
                                   len(config.pair_1),
                                   passed_prefix_total * 100.0 / actual_number_of_pairs,
                                   zero_mismatches_total * 100.0 / (passed_prefix_total or 1)
                                   ))
                else:
                    input_1.print_percentage('[Merging %d of %d]' % (index + 1, len(config.pair_1)))


            # taking care of prefixes if there are any..
            if pair_1_prefix_compiled:
                pattern_1 = pair_1_prefix_compiled.search(input_1.entry.sequence)
                if pattern_1:
                    input_1.entry.trim(trim_from = pattern_1.end())
                    
            if pair_2_prefix_compiled:
                pattern_2 = pair_2_prefix_compiled.search(input_2.entry.sequence)
                if pattern_2:
                    input_2.entry.trim(trim_from = pattern_2.end())

            failed_prefix = False
            
            if pair_1_prefix_compiled and (not pattern_1):
                failed_prefix = True
                prefix_failed_in_pair_1_total += 1
            if pair_2_prefix_compiled and (not pattern_2):
                failed_prefix = True
                prefix_failed_in_pair_2_total += 1
            if (pair_1_prefix_compiled and (not pattern_1)) and (pair_2_prefix_compiled and (not pattern_2)):
                prefix_failed_in_both_pairs_total += 1

            if failed_prefix:
                failed_prefix_total += 1
                continue
            if not failed_prefix:
                passed_prefix_total += 1


            # merging..
            merged_sequence = merge_two_sequences(input_1.entry.sequence, reverse_complement(input_2.entry.sequence))

            len_overlap = (len(input_1.entry.sequence) + len(input_2.entry.sequence)) - len(merged_sequence)
            number_of_conflicts = NumberOfConflicts(merged_sequence)
            if number_of_conflicts == 0:
                zero_mismatches_total += 1

            p = 1.0 * number_of_conflicts / len_overlap

            if p > 0.3:
                failed.write_id('%s|o/m:%f|mismatches:%d' % (input_1.entry.header_line, p, number_of_conflicts))
                failed.write_seq(merged_sequence, split = False)
            else:
                output.write_id('%s|o/m:%f|mismatches:%d' % (input_1.entry.header_line, p, number_of_conflicts))
                output.write_seq(merged_sequence, split = False)

            if compute_qual_dicts:
                ################ quality dicts associated stuff ####################
                if len(merged_sequence) > 185:
                    ind = -1
                elif number_of_conflicts >= 5:
                    ind = 5
                else:
                    ind = number_of_conflicts

                tiles_dict = quality_dicts[ind]

                if not tiles_dict['1'].has_key(input_1.entry.tile_number):
                    tiles_dict['1'][input_1.entry.tile_number] = []
                    for i in range(0, 101):
                        tiles_dict['1'][input_1.entry.tile_number].append([])
   
                q1 = input_1.entry.process_Q_list()
                
                for i in range(0, len(q1)):
                    tiles_dict['1'][input_1.entry.tile_number][i].append(q1[i])

                if not tiles_dict['2'].has_key(input_2.entry.tile_number):
                    tiles_dict['2'][input_2.entry.tile_number] = []
                    for i in range(0, 101):
                        tiles_dict['2'][input_2.entry.tile_number].append([])
                
                q2 = input_2.entry.process_Q_list()
                
                for i in range(0, len(q2)):
                    tiles_dict['2'][input_2.entry.tile_number][i].append(q2[i])
                
                ################ / quality dicts associated stuff ####################
 
        print
        input_1.close()
        input_2.close()

    output.close()
    failed.close()

    if compute_qual_dicts:
        ################ quality dicts associated stuff ####################
        for ind in quality_dicts:
            qual_dict = quality_dicts[ind]
            if ind == -1:
                cPickle.dump(qual_dict, open(os.path.join(config.output_directory, output_file_prefix + '_MERGED_BAD_LENGTH_QUAL_DICT'), 'w'))
            else:
                cPickle.dump(qual_dict, open(os.path.join(config.output_directory, output_file_prefix + '_MERGED_%d_MISMATCH_QUAL_DICT' % ind), 'w'))
        ################ / quality dicts associated stuff ####################


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description='Merge Overlapping Paired-End Illumina Reads')
    parser.add_argument('user_config', metavar = 'CONFIG_FILE',
                                        help = 'User configuration to run')
    parser.add_argument('output_file_prefix', metavar = 'OUTPUT_FILE_PREFIX',
                                        help = 'Output file prefix (which will be used as a prefix\
                                                for files that appear in output directory)')
    parser.add_argument('--min-overlap-size', type = int, default = 15,
                                        help = 'Minimum expected overlap. Default is 15 nts.')
    parser.add_argument('--compute-qual-dicts', action = 'store_true', default = False,
                                        help = 'When set, qual ditcs will be computed. May take a\
                                                very long time for datasets with more than a\
                                                million pairs.')
    parser.add_argument('--pair-1-prefix', type = str, default = None,
                                        help = 'Regexp to be found at the beginning of pair 1\
                                                and trimmed. If the regexp fails for a given pair,\
                                                it will not be merged.')
    parser.add_argument('--pair-2-prefix', type = str, default = None,
                                        help = 'Same as --pair-1-prefix for pair 2')

    args = parser.parse_args()
    user_config = ConfigParser.ConfigParser()
    user_config.read(args.user_config)

    try: 
        config = RunConfiguration(user_config)
    except ConfigError, e:
        print "There is something wrong with the config file. This is what we know: \n\n", e
        print
        sys.exit()

    sys.exit(main(config,
                  args.output_file_prefix,
                  args.compute_qual_dicts,
                  args.pair_1_prefix,
                  args.pair_2_prefix))
